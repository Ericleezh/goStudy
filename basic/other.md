### Other
---

##### #1.关于递归时栈溢出问题的解决
* [懒惰求值法](https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC)
* channel 实现
* goroutine 实现

##### #2.将数组传递给函数造成大量内存消耗，解决方法：
* 传递数组的指针
* 使用数组的切片

##### #3.为自定义包使用godoc
* 注释必须以 `//` 开头并无空行放在声明前
* 命令行下进入目录使用命令： `godoc -http=:6060 -goroot="."` （ . 表示当前路径） 执行后进入 `localhost:6060`即可看到对应的文档
* 通过设置 `sync_minutes=n` 可以使文档每n分钟自动更新

##### #4.如何在类型中嵌入功能
* 聚合（组合）:包含一个所需功能类型的具名字段
* 内嵌：内嵌（匿名地）所需功能类型。（不需要指针）

##### #5.多重继承
* 多重继承指的是获得多个父亲行为的能力，传统的面向对象的语言中通常是不被实现的(C++和Python例外),在Go语言中，通过在类型中嵌入所必须的父类型，可以简单的实现多重继承。

##### #6.和其他面向对象语言比较 Go 的类型和方法
* 在大部分面向对象语言中，方法在类的上下文中被定义和继承，在调用方法时，运行时会检测类以及它的超类中是否有此方法的定义，若没有会导致异常发生；**而在Go中，只要方法在该类型中定义了，就可以调用他，与其他类型上是否有该方法没有关系。**

##### #7.To sum up for go of 'class' (关于在Go中‘类’的总结) [goop](https://github.com/losalamos/goop)
> Go中，类型就是类（数据和关联的 方法）
> 代码复用通过**组合和委托**实现，多态通过接口的使用来实现，也叫组件编程

##### #8.若接口中的方法没有被实现，即使没有地方进行调用，同样会给出没有实现的编译错误。
* 那意思就是我定义了一定要实现咯，若只是需要先定义，实现暂未想好，岂不是很坑。

##### #9.类型断言：如何检测和转换接口变量的类型
* v 是 varI 转换到类型 T 的值，ok 会是 true；否则 v 是类型 T 的零值，ok 是 false
```go
if v, ok := varI.(T); ok {  // checked type assertion
    Process(v)
    return
}
// varI is not of type T
```

##### #10.测试一个值是否实现了某个接口
```go
type Stringer interface {
    String() string
}

if sv, ok := v.(Stringer); ok {
    fmt.Printf("v implements String(): %s\n", sv.String()) // note: sv, not v
}
```

##### #11.显式地指明类型实现了某个接口(限制接口的实用性)
* 通过向接口添加一个具有描述性的方法，则类型必须实现该方法来满足接口

##### #12.Go 中的面向对象，Go 没有类，而是松耦合的类型、方法对接口的实现。
* 封装（数据隐藏）：和别的 OO 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层
    - 包范围内的：通过标识符首**字母小写**，`对象`只在它所在的包内可见
    - 可导出的：通过标识符首**字母大写**，`对象`对所在包以外也可见
* 继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现
* 多态：用接口实现：**某个类型的实例可以赋给它所实现的任意接口类型的变量**。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。

##### #13.Go中的字符串格式化 [Link](https://www.cnblogs.com/wt645631686/p/9643497.html)
* `%v`打印了一个point结构体的对象的值
```go
p := point{1, 2}
fmt.Printf("%v\n", p)
```
* `%+v`的格式化输出将包括结构体的成员名称和值
```go
fmt.Printf("%+v\n", p)
```
* `%#v`的格式化将会输出值的Go语法表示方式
```go
fmt.Printf("%#v\n", p)
```
* `%T`输出值的数据类型
```go
fmt.Printf("%T\n", p)
```
* `%b`输出值二进制方式
```go
fmt.Printf("%b\n", 14)
```

##### #14.一种用闭包处理错误的模式
* 应用场景:每次函数返回时，重复的检查错误发生是乏味的。结合`defer/panic/recover`机制和`闭包`的模式可以解决该类问题，不过该模式需要所有的函数都是同一种签名(web引用中)

##### #15. gotest中调用测试方法/函数提示`Undefined: XXX`
* 问题来源:go test会执行所有`_test`结尾的文件进行测试，但并不会执行所需调用方法的文件，即方法所对应的文件并没有被编译到，也就出现了方法未定义的问题。
* 解决办法：go test执行时参数带上相关的文件一起编译执行,例:`go test -v od_test.go even.go`

